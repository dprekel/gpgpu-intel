General things:
- No standalone functions, only class methods!


Device Initialization:

CreateContext:
- create userptr for TagBuffer and PreemptionBuffer

CreateBuffer:
- check if allocated memory is page aligned and a multiple of the cache line size
- finish execBuffer submission

BuildKernel:
- Write functions for determination of interface IDs and InterfaceVersions
- Write function for construction of internalOptions string (query info from device structs)
- Freeing memory after compilation (writing destructor)
- Understand how program binary is intercepted from Intercept Layer
- Test driver with different IGC versions from Github and Ubuntu repos
- Is Mutex required?
- Add macros with Error codes
- create userptr for Kernel

clSetKernelArg:
- What happens here?

clEnqueueNDRangeKernel:
- GEN9 commands (which ones are important?):
    - BINDING_TABLE_STATE
    - GPGPU_WALKER
    - INTERFACE_DESCRIPTOR_DATA
    - MEDIA_INTERFACE_DESCRIPTOR_LOAD
    - MEDIA_STATE_FLUSH
    - MEDIA_VFE_STATE
    - MI_ARB_CHECK
    - MI_ATOMIC
    - MI_BATCH_BUFFER_END
    - MI_BATCH_BUFFER_START
    - MI_LOAD_REGISTER_IMM
    - MI_LOAD_REGISTER_MEM
    - MI_LOAD_REGISTER_REG
    - MI_NOOP
    - MI_STORE_REGISTER_MEM
    - PIPELINE_SELECT
    - PIPE_CONTROL
    - RENDER_SURFACE_STATE
    - SAMPLER_STATE
    - STATE_BASE_ADDRESS
    - MI_REPORT_PERF_COUNT
    - GPGPU_CSR_BASE_ADDRESS
    - STATE_SIP
    - MI_USER_INTERRUPT
    - MI_FLUSH_DW
    - XY_SRC_COPY_BLT
    - XY_COLOR_BLT
    - GRF
    - MEDIA_SURFACE_STATE
    - MI_MATH
    - MI_MATH_ALU_INST_INLINE
    - MI_SEMAPHORE_WAIT
    - MI_STORE_DATA_IMM
    - SAMPLER_BORDER_COLOR_STATE


dispatchWalker()  hardware_interface_base.inl   (otain indirect heaps, align dsh, Kernel Tuning, dispatch Kernel commands, flush caches)
    |
    v
dispatchKernelCommands()  hardware_interface_base.inl   (workgroup offsets, programWalker)
    |
    v
programWalker()  hardware_interface_bdw_and_later.inl   (sendIndirectState + setGpgpuWalkerThreadData)
    |
    v
sendIndirectState()  hardware_commands_helper_base.inl  (fill dsh, ioh, ssh)





- Finish all buffer objects
- Support kernel compilation for all other architectures
- Improve data buffer allocation
- Get rid of all memory leaks
- Think about how the API should look like
- Kernel binary encoding to ELF format
- Disassemble the ELF binary by linking to IGA library
- Add Release() function that destroys all heap objects
- Add clFinish functionality
- Merge gpuInfo and Device classes
- Use new for aligned malloc
- Make sure all API functions can only be called in correct order
- Add aligned free for buffer objects

DumpProgramBinaries command:
$ gdb --args ./cliloader --dump-output-binaries ./GEMM


Ideas for a better API:
- DeviceStub* CreateDevice(int ret);
- int CreateContext(DeviceStub* device);
- int BuildKernel(DeviceStub* device, const char* filename, const char* options, int arch, bool disas);
- int EnqueueNDRangeKernel(DeviceStub* device, uint32_t work_dim, const size_t* global_work_offset, const size_t* global_work_size, const size_t* local_work_size);

The context class will contain a vector of kernel objects. Only the kernel that can be executed on the hardware will be enqueued.





